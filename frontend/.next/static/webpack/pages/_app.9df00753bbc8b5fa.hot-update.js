"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./contexts/CreditIntelligenceContext.tsx":
/*!************************************************!*\
  !*** ./contexts/CreditIntelligenceContext.tsx ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CreditIntelligenceProvider: function() { return /* binding */ CreditIntelligenceProvider; },\n/* harmony export */   useCreditIntelligence: function() { return /* binding */ useCreditIntelligence; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\nconst CreditIntelligenceContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst CreditIntelligenceProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const [profile, setProfile] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [analytics, setAnalytics] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [achievements, setAchievements] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [activeProofs, setActiveProofs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [privacyMode, setPrivacyModeState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [connectedAddress, setConnectedAddress] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Mock data for demonstration - in real implementation, this would come from the service\n    const mockProfile = {\n        address: \"0x742d35Cc6634C0532925a3b8D4C9db96590b5b8c\",\n        linkedWallets: [\n            \"0x742d35Cc6634C0532925a3b8D4C9db96590b5b8c\"\n        ],\n        overallScore: 847,\n        tier: \"Platinum\",\n        dimensions: {\n            defiReliability: {\n                score: 892,\n                confidence: 94,\n                trend: \"improving\",\n                dataPoints: 156,\n                lastCalculated: Date.now(),\n                recommendations: [\n                    \"Continue consistent DeFi interactions\",\n                    \"Explore new protocols to diversify\"\n                ]\n            },\n            tradingConsistency: {\n                score: 734,\n                confidence: 87,\n                trend: \"stable\",\n                dataPoints: 89,\n                lastCalculated: Date.now(),\n                recommendations: [\n                    \"Maintain current trading patterns\",\n                    \"Consider longer-term positions\"\n                ]\n            },\n            stakingCommitment: {\n                score: 923,\n                confidence: 96,\n                trend: \"improving\",\n                dataPoints: 203,\n                lastCalculated: Date.now(),\n                recommendations: [\n                    \"Excellent staking behavior\",\n                    \"Consider staking in additional protocols\"\n                ]\n            },\n            governanceParticipation: {\n                score: 612,\n                confidence: 73,\n                trend: \"declining\",\n                dataPoints: 34,\n                lastCalculated: Date.now(),\n                recommendations: [\n                    \"Increase DAO participation\",\n                    \"Vote in upcoming proposals\",\n                    \"Join governance discussions\"\n                ]\n            },\n            liquidityProvider: {\n                score: 856,\n                confidence: 91,\n                trend: \"stable\",\n                dataPoints: 127,\n                lastCalculated: Date.now(),\n                recommendations: [\n                    \"Strong LP performance\",\n                    \"Consider impermanent loss protection strategies\"\n                ]\n            }\n        },\n        socialCredit: {\n            overallRating: 4.8,\n            totalTransactions: 47,\n            successRate: 98.2,\n            communityRank: 156,\n            referrals: 12,\n            trustScore: 892,\n            p2pLendingHistory: [],\n            communityFeedback: [],\n            disputeHistory: []\n        },\n        predictions: {\n            risk30d: 12,\n            risk90d: 18,\n            risk180d: 24,\n            confidence: 87,\n            insights: [\n                \"Strong DeFi engagement reduces short-term risk\",\n                \"Governance participation could improve long-term outlook\",\n                \"Market volatility may affect 180-day predictions\"\n            ],\n            marketVolatilityAdjustment: 1.2\n        },\n        achievements: [],\n        lastUpdated: Date.now()\n    };\n    const mockAnalytics = {\n        scoreHistory: [\n            {\n                timestamp: Date.now() - 86400000 * 30,\n                overallScore: 720,\n                dimensions: {}\n            },\n            {\n                timestamp: Date.now() - 86400000 * 15,\n                overallScore: 780,\n                dimensions: {}\n            },\n            {\n                timestamp: Date.now(),\n                overallScore: 847,\n                dimensions: {}\n            }\n        ],\n        behaviorTrends: [\n            {\n                category: \"DeFi Interactions\",\n                trend: 15,\n                change: \"increase\",\n                timeframe: \"30d\"\n            },\n            {\n                category: \"Staking Duration\",\n                trend: 8,\n                change: \"increase\",\n                timeframe: \"30d\"\n            },\n            {\n                category: \"Governance Votes\",\n                trend: -5,\n                change: \"decrease\",\n                timeframe: \"30d\"\n            },\n            {\n                category: \"LP Positions\",\n                trend: 12,\n                change: \"increase\",\n                timeframe: \"30d\"\n            }\n        ],\n        peerComparison: {\n            percentile: 87,\n            averageScore: 642,\n            userScore: 847,\n            totalUsers: 15420\n        },\n        transactionMetrics: {\n            totalTransactions: 89,\n            totalVolume: 234560,\n            uniqueProtocols: 8,\n            timeframe: \"30d\"\n        }\n    };\n    const mockAchievements = [\n        {\n            id: \"1\",\n            name: \"DeFi Pioneer\",\n            description: \"Complete your first DeFi transaction\",\n            rarity: \"common\",\n            progress: 1,\n            maxProgress: 1,\n            unlocked: true,\n            reward: \"+50 Social Credit\",\n            unlockedAt: Date.now() - 86400000 * 30\n        },\n        {\n            id: \"2\",\n            name: \"Trusted Lender\",\n            description: \"Successfully complete 10 P2P lending transactions\",\n            rarity: \"rare\",\n            progress: 8,\n            maxProgress: 10,\n            unlocked: false,\n            reward: \"+200 Social Credit + Lender Badge\"\n        },\n        {\n            id: \"3\",\n            name: \"Community Builder\",\n            description: \"Refer 5 users who achieve good credit scores\",\n            rarity: \"epic\",\n            progress: 3,\n            maxProgress: 5,\n            unlocked: false,\n            reward: \"+500 Social Credit + Referral Multiplier\"\n        }\n    ];\n    // Load data from API when address is connected\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (connectedAddress) {\n            loadProfileData(connectedAddress);\n        } else {\n            setProfile(null);\n            setAnalytics(null);\n            setAchievements([]);\n            setActiveProofs([]);\n        }\n    }, [\n        connectedAddress\n    ]);\n    const loadProfileData = async (address)=>{\n        setLoading(true);\n        try {\n            // Load profile from API\n            const profileResponse = await fetch(\"http://localhost:3001/api/credit-profile/\".concat(address));\n            if (profileResponse.ok) {\n                const profileData = await profileResponse.json();\n                setProfile(profileData);\n                setAchievements(profileData.achievements || []);\n            }\n            // Load analytics from API\n            const analyticsResponse = await fetch(\"http://localhost:3001/api/analytics/\".concat(address, \"?timeframe=30d\"));\n            if (analyticsResponse.ok) {\n                const analyticsData = await analyticsResponse.json();\n                setAnalytics(analyticsData);\n            }\n        } catch (error) {\n            console.error(\"Error loading profile data:\", error);\n            setError(\"Failed to load profile data\");\n        } finally{\n            setLoading(false);\n        }\n    };\n    const connectWallet = async (address)=>{\n        setLoading(true);\n        setError(null);\n        try {\n            setConnectedAddress(address);\n        // In real implementation, fetch actual data from the service\n        // const profile = await creditIntelligenceService.getCreditProfile(address);\n        // setProfile(profile);\n        } catch (err) {\n            setError(\"Failed to connect wallet and load profile\");\n            console.error(\"Wallet connection error:\", err);\n        } finally{\n            setLoading(false);\n        }\n    };\n    const disconnectWallet = ()=>{\n        setConnectedAddress(null);\n        setProfile(null);\n        setAnalytics(null);\n        setAchievements([]);\n        setActiveProofs([]);\n        setError(null);\n    };\n    const refreshProfile = async ()=>{\n        if (!connectedAddress) return;\n        setLoading(true);\n        try {\n            // In real implementation:\n            // const profile = await creditIntelligenceService.getCreditProfile(connectedAddress);\n            // setProfile(profile);\n            // For now, just refresh the mock data\n            setProfile({\n                ...mockProfile,\n                lastUpdated: Date.now()\n            });\n        } catch (err) {\n            setError(\"Failed to refresh profile\");\n            console.error(\"Profile refresh error:\", err);\n        } finally{\n            setLoading(false);\n        }\n    };\n    const refreshAnalytics = async function() {\n        let timeframe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"30d\";\n        if (!connectedAddress) return;\n        setLoading(true);\n        try {\n            // In real implementation:\n            // const analytics = await creditIntelligenceService.getAnalytics(connectedAddress, timeframe);\n            // setAnalytics(analytics);\n            // For now, just refresh the mock data\n            setAnalytics(mockAnalytics);\n        } catch (err) {\n            setError(\"Failed to refresh analytics\");\n            console.error(\"Analytics refresh error:\", err);\n        } finally{\n            setLoading(false);\n        }\n    };\n    const refreshAchievements = async ()=>{\n        if (!connectedAddress) return;\n        try {\n            // In real implementation:\n            // const achievements = await creditIntelligenceService.getAchievements(connectedAddress);\n            // setAchievements(achievements);\n            // For now, just refresh the mock data\n            setAchievements(mockAchievements);\n        } catch (err) {\n            setError(\"Failed to refresh achievements\");\n            console.error(\"Achievements refresh error:\", err);\n        }\n    };\n    const refreshProofs = async ()=>{\n        if (!connectedAddress) return;\n        try {\n            // In real implementation:\n            // const proofs = await creditIntelligenceService.getActiveProofs(connectedAddress);\n            // setActiveProofs(proofs);\n            // For now, use empty array\n            setActiveProofs([]);\n        } catch (err) {\n            setError(\"Failed to refresh proofs\");\n            console.error(\"Proofs refresh error:\", err);\n        }\n    };\n    const setPrivacyMode = (enabled)=>{\n        setPrivacyModeState(enabled);\n    // In real implementation, this might also update server-side preferences\n    };\n    const generateProof = async (type, options)=>{\n        if (!connectedAddress) return null;\n        setLoading(true);\n        try {\n            // In real implementation:\n            // const proof = await creditIntelligenceService.generateZKProof(connectedAddress, type, options);\n            // For now, create a mock proof\n            const mockProof = {\n                id: Date.now().toString(),\n                type,\n                status: \"ready\",\n                threshold: type === \"threshold\" ? options.threshold : undefined,\n                dimensions: type === \"selective\" ? options.dimensions : undefined,\n                proof: \"zk\".concat(Math.random().toString(36).substring(2)).concat(Date.now()),\n                timestamp: Date.now(),\n                expiresAt: Date.now() + 86400000 // 24 hours\n            };\n            setActiveProofs((prev)=>[\n                    mockProof,\n                    ...prev\n                ]);\n            return mockProof;\n        } catch (err) {\n            setError(\"Failed to generate proof\");\n            console.error(\"Proof generation error:\", err);\n            return null;\n        } finally{\n            setLoading(false);\n        }\n    };\n    const claimAchievement = async (achievementId)=>{\n        if (!connectedAddress) return false;\n        try {\n            // In real implementation:\n            // const success = await creditIntelligenceService.claimAchievement(connectedAddress, achievementId);\n            // For now, just mark as unlocked\n            setAchievements((prev)=>prev.map((achievement)=>achievement.id === achievementId ? {\n                        ...achievement,\n                        unlocked: true,\n                        unlockedAt: Date.now()\n                    } : achievement));\n            return true;\n        } catch (err) {\n            setError(\"Failed to claim achievement\");\n            console.error(\"Achievement claim error:\", err);\n            return false;\n        }\n    };\n    const exportData = async (options)=>{\n        if (!connectedAddress) return null;\n        try {\n            // In real implementation:\n            // return await creditIntelligenceService.exportAnalytics(connectedAddress, options);\n            // For now, create a mock export\n            const exportData = {\n                profile: privacyMode ? null : profile,\n                analytics: privacyMode ? null : analytics,\n                achievements,\n                timestamp: new Date().toISOString(),\n                privacyMode\n            };\n            return new Blob([\n                JSON.stringify(exportData, null, 2)\n            ], {\n                type: \"application/json\"\n            });\n        } catch (err) {\n            setError(\"Failed to export data\");\n            console.error(\"Data export error:\", err);\n            return null;\n        }\n    };\n    const value = {\n        // State\n        profile,\n        analytics,\n        achievements,\n        activeProofs,\n        loading,\n        error,\n        // User preferences\n        privacyMode,\n        connectedAddress,\n        // Actions\n        connectWallet,\n        disconnectWallet,\n        refreshProfile,\n        refreshAnalytics,\n        refreshAchievements,\n        refreshProofs,\n        setPrivacyMode,\n        generateProof,\n        claimAchievement,\n        exportData\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CreditIntelligenceContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"E:\\\\BlockCreditScore\\\\frontend\\\\contexts\\\\CreditIntelligenceContext.tsx\",\n        lineNumber: 501,\n        columnNumber: 5\n    }, undefined);\n};\n_s(CreditIntelligenceProvider, \"hJO1dXMM86F7xpGg6F2fu6JUh/8=\");\n_c = CreditIntelligenceProvider;\nconst useCreditIntelligence = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(CreditIntelligenceContext);\n    if (context === undefined) {\n        throw new Error(\"useCreditIntelligence must be used within a CreditIntelligenceProvider\");\n    }\n    return context;\n};\n_s1(useCreditIntelligence, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n/* harmony default export */ __webpack_exports__[\"default\"] = (CreditIntelligenceContext);\nvar _c;\n$RefreshReg$(_c, \"CreditIntelligenceProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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M0gsV0FBVztRQUN6QixNQUFNLElBQUk0SCxNQUFNO0lBQ2xCO0lBQ0EsT0FBT0Q7QUFDVCxFQUFFO0lBTldEO0FBUWIsK0RBQWUzSCx5QkFBeUJBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29udGV4dHMvQ3JlZGl0SW50ZWxsaWdlbmNlQ29udGV4dC50c3g/NDc2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuXG5pbnRlcmZhY2UgU2NvcmVEaW1lbnNpb24ge1xuICBzY29yZTogbnVtYmVyO1xuICBjb25maWRlbmNlOiBudW1iZXI7XG4gIHRyZW5kOiAnaW1wcm92aW5nJyB8ICdzdGFibGUnIHwgJ2RlY2xpbmluZyc7XG4gIGRhdGFQb2ludHM6IG51bWJlcjtcbiAgbGFzdENhbGN1bGF0ZWQ6IG51bWJlcjtcbiAgcmVjb21tZW5kYXRpb25zOiBzdHJpbmdbXTtcbn1cblxuaW50ZXJmYWNlIFNvY2lhbENyZWRpdERhdGEge1xuICBvdmVyYWxsUmF0aW5nOiBudW1iZXI7XG4gIHRvdGFsVHJhbnNhY3Rpb25zOiBudW1iZXI7XG4gIHN1Y2Nlc3NSYXRlOiBudW1iZXI7XG4gIGNvbW11bml0eVJhbms6IG51bWJlcjtcbiAgcmVmZXJyYWxzOiBudW1iZXI7XG4gIHRydXN0U2NvcmU6IG51bWJlcjtcbiAgcDJwTGVuZGluZ0hpc3Rvcnk6IGFueVtdO1xuICBjb21tdW5pdHlGZWVkYmFjazogYW55W107XG4gIGRpc3B1dGVIaXN0b3J5OiBhbnlbXTtcbn1cblxuaW50ZXJmYWNlIFJpc2tQcmVkaWN0aW9uIHtcbiAgcmlzazMwZDogbnVtYmVyO1xuICByaXNrOTBkOiBudW1iZXI7XG4gIHJpc2sxODBkOiBudW1iZXI7XG4gIGNvbmZpZGVuY2U6IG51bWJlcjtcbiAgaW5zaWdodHM6IHN0cmluZ1tdO1xuICBtYXJrZXRWb2xhdGlsaXR5QWRqdXN0bWVudDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgQWNoaWV2ZW1lbnQge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIHJhcml0eTogJ2NvbW1vbicgfCAncmFyZScgfCAnZXBpYycgfCAnbGVnZW5kYXJ5JztcbiAgcHJvZ3Jlc3M6IG51bWJlcjtcbiAgbWF4UHJvZ3Jlc3M6IG51bWJlcjtcbiAgdW5sb2NrZWQ6IGJvb2xlYW47XG4gIHJld2FyZDogc3RyaW5nO1xuICB1bmxvY2tlZEF0PzogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgQ3JlZGl0UHJvZmlsZSB7XG4gIGFkZHJlc3M6IHN0cmluZztcbiAgbGlua2VkV2FsbGV0czogc3RyaW5nW107XG4gIG92ZXJhbGxTY29yZTogbnVtYmVyO1xuICB0aWVyOiBzdHJpbmc7XG4gIGRpbWVuc2lvbnM6IHtcbiAgICBkZWZpUmVsaWFiaWxpdHk6IFNjb3JlRGltZW5zaW9uO1xuICAgIHRyYWRpbmdDb25zaXN0ZW5jeTogU2NvcmVEaW1lbnNpb247XG4gICAgc3Rha2luZ0NvbW1pdG1lbnQ6IFNjb3JlRGltZW5zaW9uO1xuICAgIGdvdmVybmFuY2VQYXJ0aWNpcGF0aW9uOiBTY29yZURpbWVuc2lvbjtcbiAgICBsaXF1aWRpdHlQcm92aWRlcjogU2NvcmVEaW1lbnNpb247XG4gIH07XG4gIHNvY2lhbENyZWRpdDogU29jaWFsQ3JlZGl0RGF0YTtcbiAgcHJlZGljdGlvbnM6IFJpc2tQcmVkaWN0aW9uO1xuICBhY2hpZXZlbWVudHM6IEFjaGlldmVtZW50W107XG4gIGxhc3RVcGRhdGVkOiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBBbmFseXRpY3NEYXRhIHtcbiAgc2NvcmVIaXN0b3J5OiBhbnlbXTtcbiAgYmVoYXZpb3JUcmVuZHM6IGFueVtdO1xuICBwZWVyQ29tcGFyaXNvbjogYW55O1xuICB0cmFuc2FjdGlvbk1ldHJpY3M6IGFueTtcbn1cblxuaW50ZXJmYWNlIFpLUHJvb2Yge1xuICBpZDogc3RyaW5nO1xuICB0eXBlOiAndGhyZXNob2xkJyB8ICdzZWxlY3RpdmUnIHwgJ2Z1bGwnO1xuICBzdGF0dXM6ICdnZW5lcmF0aW5nJyB8ICdyZWFkeScgfCAndmVyaWZpZWQnIHwgJ2V4cGlyZWQnO1xuICB0aHJlc2hvbGQ/OiBudW1iZXI7XG4gIGRpbWVuc2lvbnM/OiBzdHJpbmdbXTtcbiAgcHJvb2Y6IHN0cmluZztcbiAgdGltZXN0YW1wOiBudW1iZXI7XG4gIGV4cGlyZXNBdDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgQ3JlZGl0SW50ZWxsaWdlbmNlQ29udGV4dFR5cGUge1xuICAvLyBTdGF0ZVxuICBwcm9maWxlOiBDcmVkaXRQcm9maWxlIHwgbnVsbDtcbiAgYW5hbHl0aWNzOiBBbmFseXRpY3NEYXRhIHwgbnVsbDtcbiAgYWNoaWV2ZW1lbnRzOiBBY2hpZXZlbWVudFtdO1xuICBhY3RpdmVQcm9vZnM6IFpLUHJvb2ZbXTtcbiAgbG9hZGluZzogYm9vbGVhbjtcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7XG4gIFxuICAvLyBVc2VyIHByZWZlcmVuY2VzXG4gIHByaXZhY3lNb2RlOiBib29sZWFuO1xuICBjb25uZWN0ZWRBZGRyZXNzOiBzdHJpbmcgfCBudWxsO1xuICBcbiAgLy8gQWN0aW9uc1xuICBjb25uZWN0V2FsbGV0OiAoYWRkcmVzczogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBkaXNjb25uZWN0V2FsbGV0OiAoKSA9PiB2b2lkO1xuICByZWZyZXNoUHJvZmlsZTogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgcmVmcmVzaEFuYWx5dGljczogKHRpbWVmcmFtZT86IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgcmVmcmVzaEFjaGlldmVtZW50czogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgcmVmcmVzaFByb29mczogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgc2V0UHJpdmFjeU1vZGU6IChlbmFibGVkOiBib29sZWFuKSA9PiB2b2lkO1xuICBnZW5lcmF0ZVByb29mOiAodHlwZTogJ3RocmVzaG9sZCcgfCAnc2VsZWN0aXZlJyB8ICdmdWxsJywgb3B0aW9uczogYW55KSA9PiBQcm9taXNlPFpLUHJvb2YgfCBudWxsPjtcbiAgY2xhaW1BY2hpZXZlbWVudDogKGFjaGlldmVtZW50SWQ6IHN0cmluZykgPT4gUHJvbWlzZTxib29sZWFuPjtcbiAgZXhwb3J0RGF0YTogKG9wdGlvbnM6IGFueSkgPT4gUHJvbWlzZTxCbG9iIHwgbnVsbD47XG59XG5cbmNvbnN0IENyZWRpdEludGVsbGlnZW5jZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PENyZWRpdEludGVsbGlnZW5jZUNvbnRleHRUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuXG5pbnRlcmZhY2UgQ3JlZGl0SW50ZWxsaWdlbmNlUHJvdmlkZXJQcm9wcyB7XG4gIGNoaWxkcmVuOiBSZWFjdE5vZGU7XG59XG5cbmV4cG9ydCBjb25zdCBDcmVkaXRJbnRlbGxpZ2VuY2VQcm92aWRlcjogUmVhY3QuRkM8Q3JlZGl0SW50ZWxsaWdlbmNlUHJvdmlkZXJQcm9wcz4gPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IFtwcm9maWxlLCBzZXRQcm9maWxlXSA9IHVzZVN0YXRlPENyZWRpdFByb2ZpbGUgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2FuYWx5dGljcywgc2V0QW5hbHl0aWNzXSA9IHVzZVN0YXRlPEFuYWx5dGljc0RhdGEgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2FjaGlldmVtZW50cywgc2V0QWNoaWV2ZW1lbnRzXSA9IHVzZVN0YXRlPEFjaGlldmVtZW50W10+KFtdKTtcbiAgY29uc3QgW2FjdGl2ZVByb29mcywgc2V0QWN0aXZlUHJvb2ZzXSA9IHVzZVN0YXRlPFpLUHJvb2ZbXT4oW10pO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtwcml2YWN5TW9kZSwgc2V0UHJpdmFjeU1vZGVTdGF0ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtjb25uZWN0ZWRBZGRyZXNzLCBzZXRDb25uZWN0ZWRBZGRyZXNzXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIC8vIE1vY2sgZGF0YSBmb3IgZGVtb25zdHJhdGlvbiAtIGluIHJlYWwgaW1wbGVtZW50YXRpb24sIHRoaXMgd291bGQgY29tZSBmcm9tIHRoZSBzZXJ2aWNlXG4gIGNvbnN0IG1vY2tQcm9maWxlOiBDcmVkaXRQcm9maWxlID0ge1xuICAgIGFkZHJlc3M6ICcweDc0MmQzNUNjNjYzNEMwNTMyOTI1YTNiOEQ0QzlkYjk2NTkwYjViOGMnLFxuICAgIGxpbmtlZFdhbGxldHM6IFsnMHg3NDJkMzVDYzY2MzRDMDUzMjkyNWEzYjhENEM5ZGI5NjU5MGI1YjhjJ10sXG4gICAgb3ZlcmFsbFNjb3JlOiA4NDcsXG4gICAgdGllcjogJ1BsYXRpbnVtJyxcbiAgICBkaW1lbnNpb25zOiB7XG4gICAgICBkZWZpUmVsaWFiaWxpdHk6IHtcbiAgICAgICAgc2NvcmU6IDg5MixcbiAgICAgICAgY29uZmlkZW5jZTogOTQsXG4gICAgICAgIHRyZW5kOiAnaW1wcm92aW5nJyxcbiAgICAgICAgZGF0YVBvaW50czogMTU2LFxuICAgICAgICBsYXN0Q2FsY3VsYXRlZDogRGF0ZS5ub3coKSxcbiAgICAgICAgcmVjb21tZW5kYXRpb25zOiBbJ0NvbnRpbnVlIGNvbnNpc3RlbnQgRGVGaSBpbnRlcmFjdGlvbnMnLCAnRXhwbG9yZSBuZXcgcHJvdG9jb2xzIHRvIGRpdmVyc2lmeSddXG4gICAgICB9LFxuICAgICAgdHJhZGluZ0NvbnNpc3RlbmN5OiB7XG4gICAgICAgIHNjb3JlOiA3MzQsXG4gICAgICAgIGNvbmZpZGVuY2U6IDg3LFxuICAgICAgICB0cmVuZDogJ3N0YWJsZScsXG4gICAgICAgIGRhdGFQb2ludHM6IDg5LFxuICAgICAgICBsYXN0Q2FsY3VsYXRlZDogRGF0ZS5ub3coKSxcbiAgICAgICAgcmVjb21tZW5kYXRpb25zOiBbJ01haW50YWluIGN1cnJlbnQgdHJhZGluZyBwYXR0ZXJucycsICdDb25zaWRlciBsb25nZXItdGVybSBwb3NpdGlvbnMnXVxuICAgICAgfSxcbiAgICAgIHN0YWtpbmdDb21taXRtZW50OiB7XG4gICAgICAgIHNjb3JlOiA5MjMsXG4gICAgICAgIGNvbmZpZGVuY2U6IDk2LFxuICAgICAgICB0cmVuZDogJ2ltcHJvdmluZycsXG4gICAgICAgIGRhdGFQb2ludHM6IDIwMyxcbiAgICAgICAgbGFzdENhbGN1bGF0ZWQ6IERhdGUubm93KCksXG4gICAgICAgIHJlY29tbWVuZGF0aW9uczogWydFeGNlbGxlbnQgc3Rha2luZyBiZWhhdmlvcicsICdDb25zaWRlciBzdGFraW5nIGluIGFkZGl0aW9uYWwgcHJvdG9jb2xzJ11cbiAgICAgIH0sXG4gICAgICBnb3Zlcm5hbmNlUGFydGljaXBhdGlvbjoge1xuICAgICAgICBzY29yZTogNjEyLFxuICAgICAgICBjb25maWRlbmNlOiA3MyxcbiAgICAgICAgdHJlbmQ6ICdkZWNsaW5pbmcnLFxuICAgICAgICBkYXRhUG9pbnRzOiAzNCxcbiAgICAgICAgbGFzdENhbGN1bGF0ZWQ6IERhdGUubm93KCksXG4gICAgICAgIHJlY29tbWVuZGF0aW9uczogWydJbmNyZWFzZSBEQU8gcGFydGljaXBhdGlvbicsICdWb3RlIGluIHVwY29taW5nIHByb3Bvc2FscycsICdKb2luIGdvdmVybmFuY2UgZGlzY3Vzc2lvbnMnXVxuICAgICAgfSxcbiAgICAgIGxpcXVpZGl0eVByb3ZpZGVyOiB7XG4gICAgICAgIHNjb3JlOiA4NTYsXG4gICAgICAgIGNvbmZpZGVuY2U6IDkxLFxuICAgICAgICB0cmVuZDogJ3N0YWJsZScsXG4gICAgICAgIGRhdGFQb2ludHM6IDEyNyxcbiAgICAgICAgbGFzdENhbGN1bGF0ZWQ6IERhdGUubm93KCksXG4gICAgICAgIHJlY29tbWVuZGF0aW9uczogWydTdHJvbmcgTFAgcGVyZm9ybWFuY2UnLCAnQ29uc2lkZXIgaW1wZXJtYW5lbnQgbG9zcyBwcm90ZWN0aW9uIHN0cmF0ZWdpZXMnXVxuICAgICAgfVxuICAgIH0sXG4gICAgc29jaWFsQ3JlZGl0OiB7XG4gICAgICBvdmVyYWxsUmF0aW5nOiA0LjgsXG4gICAgICB0b3RhbFRyYW5zYWN0aW9uczogNDcsXG4gICAgICBzdWNjZXNzUmF0ZTogOTguMixcbiAgICAgIGNvbW11bml0eVJhbms6IDE1NixcbiAgICAgIHJlZmVycmFsczogMTIsXG4gICAgICB0cnVzdFNjb3JlOiA4OTIsXG4gICAgICBwMnBMZW5kaW5nSGlzdG9yeTogW10sXG4gICAgICBjb21tdW5pdHlGZWVkYmFjazogW10sXG4gICAgICBkaXNwdXRlSGlzdG9yeTogW11cbiAgICB9LFxuICAgIHByZWRpY3Rpb25zOiB7XG4gICAgICByaXNrMzBkOiAxMixcbiAgICAgIHJpc2s5MGQ6IDE4LFxuICAgICAgcmlzazE4MGQ6IDI0LFxuICAgICAgY29uZmlkZW5jZTogODcsXG4gICAgICBpbnNpZ2h0czogW1xuICAgICAgICAnU3Ryb25nIERlRmkgZW5nYWdlbWVudCByZWR1Y2VzIHNob3J0LXRlcm0gcmlzaycsXG4gICAgICAgICdHb3Zlcm5hbmNlIHBhcnRpY2lwYXRpb24gY291bGQgaW1wcm92ZSBsb25nLXRlcm0gb3V0bG9vaycsXG4gICAgICAgICdNYXJrZXQgdm9sYXRpbGl0eSBtYXkgYWZmZWN0IDE4MC1kYXkgcHJlZGljdGlvbnMnXG4gICAgICBdLFxuICAgICAgbWFya2V0Vm9sYXRpbGl0eUFkanVzdG1lbnQ6IDEuMlxuICAgIH0sXG4gICAgYWNoaWV2ZW1lbnRzOiBbXSxcbiAgICBsYXN0VXBkYXRlZDogRGF0ZS5ub3coKVxuICB9O1xuXG4gIGNvbnN0IG1vY2tBbmFseXRpY3M6IEFuYWx5dGljc0RhdGEgPSB7XG4gICAgc2NvcmVIaXN0b3J5OiBbXG4gICAgICB7IHRpbWVzdGFtcDogRGF0ZS5ub3coKSAtIDg2NDAwMDAwICogMzAsIG92ZXJhbGxTY29yZTogNzIwLCBkaW1lbnNpb25zOiB7fSB9LFxuICAgICAgeyB0aW1lc3RhbXA6IERhdGUubm93KCkgLSA4NjQwMDAwMCAqIDE1LCBvdmVyYWxsU2NvcmU6IDc4MCwgZGltZW5zaW9uczoge30gfSxcbiAgICAgIHsgdGltZXN0YW1wOiBEYXRlLm5vdygpLCBvdmVyYWxsU2NvcmU6IDg0NywgZGltZW5zaW9uczoge30gfVxuICAgIF0sXG4gICAgYmVoYXZpb3JUcmVuZHM6IFtcbiAgICAgIHsgY2F0ZWdvcnk6ICdEZUZpIEludGVyYWN0aW9ucycsIHRyZW5kOiAxNSwgY2hhbmdlOiAnaW5jcmVhc2UnLCB0aW1lZnJhbWU6ICczMGQnIH0sXG4gICAgICB7IGNhdGVnb3J5OiAnU3Rha2luZyBEdXJhdGlvbicsIHRyZW5kOiA4LCBjaGFuZ2U6ICdpbmNyZWFzZScsIHRpbWVmcmFtZTogJzMwZCcgfSxcbiAgICAgIHsgY2F0ZWdvcnk6ICdHb3Zlcm5hbmNlIFZvdGVzJywgdHJlbmQ6IC01LCBjaGFuZ2U6ICdkZWNyZWFzZScsIHRpbWVmcmFtZTogJzMwZCcgfSxcbiAgICAgIHsgY2F0ZWdvcnk6ICdMUCBQb3NpdGlvbnMnLCB0cmVuZDogMTIsIGNoYW5nZTogJ2luY3JlYXNlJywgdGltZWZyYW1lOiAnMzBkJyB9XG4gICAgXSxcbiAgICBwZWVyQ29tcGFyaXNvbjoge1xuICAgICAgcGVyY2VudGlsZTogODcsXG4gICAgICBhdmVyYWdlU2NvcmU6IDY0MixcbiAgICAgIHVzZXJTY29yZTogODQ3LFxuICAgICAgdG90YWxVc2VyczogMTU0MjBcbiAgICB9LFxuICAgIHRyYW5zYWN0aW9uTWV0cmljczoge1xuICAgICAgdG90YWxUcmFuc2FjdGlvbnM6IDg5LFxuICAgICAgdG90YWxWb2x1bWU6IDIzNDU2MCxcbiAgICAgIHVuaXF1ZVByb3RvY29sczogOCxcbiAgICAgIHRpbWVmcmFtZTogJzMwZCdcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgbW9ja0FjaGlldmVtZW50czogQWNoaWV2ZW1lbnRbXSA9IFtcbiAgICB7XG4gICAgICBpZDogJzEnLFxuICAgICAgbmFtZTogJ0RlRmkgUGlvbmVlcicsXG4gICAgICBkZXNjcmlwdGlvbjogJ0NvbXBsZXRlIHlvdXIgZmlyc3QgRGVGaSB0cmFuc2FjdGlvbicsXG4gICAgICByYXJpdHk6ICdjb21tb24nLFxuICAgICAgcHJvZ3Jlc3M6IDEsXG4gICAgICBtYXhQcm9ncmVzczogMSxcbiAgICAgIHVubG9ja2VkOiB0cnVlLFxuICAgICAgcmV3YXJkOiAnKzUwIFNvY2lhbCBDcmVkaXQnLFxuICAgICAgdW5sb2NrZWRBdDogRGF0ZS5ub3coKSAtIDg2NDAwMDAwICogMzBcbiAgICB9LFxuICAgIHtcbiAgICAgIGlkOiAnMicsXG4gICAgICBuYW1lOiAnVHJ1c3RlZCBMZW5kZXInLFxuICAgICAgZGVzY3JpcHRpb246ICdTdWNjZXNzZnVsbHkgY29tcGxldGUgMTAgUDJQIGxlbmRpbmcgdHJhbnNhY3Rpb25zJyxcbiAgICAgIHJhcml0eTogJ3JhcmUnLFxuICAgICAgcHJvZ3Jlc3M6IDgsXG4gICAgICBtYXhQcm9ncmVzczogMTAsXG4gICAgICB1bmxvY2tlZDogZmFsc2UsXG4gICAgICByZXdhcmQ6ICcrMjAwIFNvY2lhbCBDcmVkaXQgKyBMZW5kZXIgQmFkZ2UnXG4gICAgfSxcbiAgICB7XG4gICAgICBpZDogJzMnLFxuICAgICAgbmFtZTogJ0NvbW11bml0eSBCdWlsZGVyJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnUmVmZXIgNSB1c2VycyB3aG8gYWNoaWV2ZSBnb29kIGNyZWRpdCBzY29yZXMnLFxuICAgICAgcmFyaXR5OiAnZXBpYycsXG4gICAgICBwcm9ncmVzczogMyxcbiAgICAgIG1heFByb2dyZXNzOiA1LFxuICAgICAgdW5sb2NrZWQ6IGZhbHNlLFxuICAgICAgcmV3YXJkOiAnKzUwMCBTb2NpYWwgQ3JlZGl0ICsgUmVmZXJyYWwgTXVsdGlwbGllcidcbiAgICB9XG4gIF07XG5cbiAgLy8gTG9hZCBkYXRhIGZyb20gQVBJIHdoZW4gYWRkcmVzcyBpcyBjb25uZWN0ZWRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY29ubmVjdGVkQWRkcmVzcykge1xuICAgICAgbG9hZFByb2ZpbGVEYXRhKGNvbm5lY3RlZEFkZHJlc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRQcm9maWxlKG51bGwpO1xuICAgICAgc2V0QW5hbHl0aWNzKG51bGwpO1xuICAgICAgc2V0QWNoaWV2ZW1lbnRzKFtdKTtcbiAgICAgIHNldEFjdGl2ZVByb29mcyhbXSk7XG4gICAgfVxuICB9LCBbY29ubmVjdGVkQWRkcmVzc10pO1xuXG4gIGNvbnN0IGxvYWRQcm9maWxlRGF0YSA9IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHRyeSB7XG4gICAgICAvLyBMb2FkIHByb2ZpbGUgZnJvbSBBUElcbiAgICAgIGNvbnN0IHByb2ZpbGVSZXNwb25zZSA9IGF3YWl0IGZldGNoKGBodHRwOi8vbG9jYWxob3N0OjMwMDEvYXBpL2NyZWRpdC1wcm9maWxlLyR7YWRkcmVzc31gKTtcbiAgICAgIGlmIChwcm9maWxlUmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgcHJvZmlsZURhdGEgPSBhd2FpdCBwcm9maWxlUmVzcG9uc2UuanNvbigpO1xuICAgICAgICBzZXRQcm9maWxlKHByb2ZpbGVEYXRhKTtcbiAgICAgICAgc2V0QWNoaWV2ZW1lbnRzKHByb2ZpbGVEYXRhLmFjaGlldmVtZW50cyB8fCBbXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIExvYWQgYW5hbHl0aWNzIGZyb20gQVBJXG4gICAgICBjb25zdCBhbmFseXRpY3NSZXNwb25zZSA9IGF3YWl0IGZldGNoKGBodHRwOi8vbG9jYWxob3N0OjMwMDEvYXBpL2FuYWx5dGljcy8ke2FkZHJlc3N9P3RpbWVmcmFtZT0zMGRgKTtcbiAgICAgIGlmIChhbmFseXRpY3NSZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBhbmFseXRpY3NEYXRhID0gYXdhaXQgYW5hbHl0aWNzUmVzcG9uc2UuanNvbigpO1xuICAgICAgICBzZXRBbmFseXRpY3MoYW5hbHl0aWNzRGF0YSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgcHJvZmlsZSBkYXRhOicsIGVycm9yKTtcbiAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gbG9hZCBwcm9maWxlIGRhdGEnKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGNvbm5lY3RXYWxsZXQgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKSA9PiB7XG4gICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgc2V0Q29ubmVjdGVkQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgIC8vIEluIHJlYWwgaW1wbGVtZW50YXRpb24sIGZldGNoIGFjdHVhbCBkYXRhIGZyb20gdGhlIHNlcnZpY2VcbiAgICAgIC8vIGNvbnN0IHByb2ZpbGUgPSBhd2FpdCBjcmVkaXRJbnRlbGxpZ2VuY2VTZXJ2aWNlLmdldENyZWRpdFByb2ZpbGUoYWRkcmVzcyk7XG4gICAgICAvLyBzZXRQcm9maWxlKHByb2ZpbGUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byBjb25uZWN0IHdhbGxldCBhbmQgbG9hZCBwcm9maWxlJyk7XG4gICAgICBjb25zb2xlLmVycm9yKCdXYWxsZXQgY29ubmVjdGlvbiBlcnJvcjonLCBlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZGlzY29ubmVjdFdhbGxldCA9ICgpID0+IHtcbiAgICBzZXRDb25uZWN0ZWRBZGRyZXNzKG51bGwpO1xuICAgIHNldFByb2ZpbGUobnVsbCk7XG4gICAgc2V0QW5hbHl0aWNzKG51bGwpO1xuICAgIHNldEFjaGlldmVtZW50cyhbXSk7XG4gICAgc2V0QWN0aXZlUHJvb2ZzKFtdKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgfTtcblxuICBjb25zdCByZWZyZXNoUHJvZmlsZSA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWNvbm5lY3RlZEFkZHJlc3MpIHJldHVybjtcbiAgICBcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHRyeSB7XG4gICAgICAvLyBJbiByZWFsIGltcGxlbWVudGF0aW9uOlxuICAgICAgLy8gY29uc3QgcHJvZmlsZSA9IGF3YWl0IGNyZWRpdEludGVsbGlnZW5jZVNlcnZpY2UuZ2V0Q3JlZGl0UHJvZmlsZShjb25uZWN0ZWRBZGRyZXNzKTtcbiAgICAgIC8vIHNldFByb2ZpbGUocHJvZmlsZSk7XG4gICAgICBcbiAgICAgIC8vIEZvciBub3csIGp1c3QgcmVmcmVzaCB0aGUgbW9jayBkYXRhXG4gICAgICBzZXRQcm9maWxlKHsgLi4ubW9ja1Byb2ZpbGUsIGxhc3RVcGRhdGVkOiBEYXRlLm5vdygpIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byByZWZyZXNoIHByb2ZpbGUnKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Byb2ZpbGUgcmVmcmVzaCBlcnJvcjonLCBlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmVmcmVzaEFuYWx5dGljcyA9IGFzeW5jICh0aW1lZnJhbWU6IHN0cmluZyA9ICczMGQnKSA9PiB7XG4gICAgaWYgKCFjb25uZWN0ZWRBZGRyZXNzKSByZXR1cm47XG4gICAgXG4gICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICB0cnkge1xuICAgICAgLy8gSW4gcmVhbCBpbXBsZW1lbnRhdGlvbjpcbiAgICAgIC8vIGNvbnN0IGFuYWx5dGljcyA9IGF3YWl0IGNyZWRpdEludGVsbGlnZW5jZVNlcnZpY2UuZ2V0QW5hbHl0aWNzKGNvbm5lY3RlZEFkZHJlc3MsIHRpbWVmcmFtZSk7XG4gICAgICAvLyBzZXRBbmFseXRpY3MoYW5hbHl0aWNzKTtcbiAgICAgIFxuICAgICAgLy8gRm9yIG5vdywganVzdCByZWZyZXNoIHRoZSBtb2NrIGRhdGFcbiAgICAgIHNldEFuYWx5dGljcyhtb2NrQW5hbHl0aWNzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gcmVmcmVzaCBhbmFseXRpY3MnKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FuYWx5dGljcyByZWZyZXNoIGVycm9yOicsIGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCByZWZyZXNoQWNoaWV2ZW1lbnRzID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghY29ubmVjdGVkQWRkcmVzcykgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBJbiByZWFsIGltcGxlbWVudGF0aW9uOlxuICAgICAgLy8gY29uc3QgYWNoaWV2ZW1lbnRzID0gYXdhaXQgY3JlZGl0SW50ZWxsaWdlbmNlU2VydmljZS5nZXRBY2hpZXZlbWVudHMoY29ubmVjdGVkQWRkcmVzcyk7XG4gICAgICAvLyBzZXRBY2hpZXZlbWVudHMoYWNoaWV2ZW1lbnRzKTtcbiAgICAgIFxuICAgICAgLy8gRm9yIG5vdywganVzdCByZWZyZXNoIHRoZSBtb2NrIGRhdGFcbiAgICAgIHNldEFjaGlldmVtZW50cyhtb2NrQWNoaWV2ZW1lbnRzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gcmVmcmVzaCBhY2hpZXZlbWVudHMnKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FjaGlldmVtZW50cyByZWZyZXNoIGVycm9yOicsIGVycik7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJlZnJlc2hQcm9vZnMgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFjb25uZWN0ZWRBZGRyZXNzKSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIEluIHJlYWwgaW1wbGVtZW50YXRpb246XG4gICAgICAvLyBjb25zdCBwcm9vZnMgPSBhd2FpdCBjcmVkaXRJbnRlbGxpZ2VuY2VTZXJ2aWNlLmdldEFjdGl2ZVByb29mcyhjb25uZWN0ZWRBZGRyZXNzKTtcbiAgICAgIC8vIHNldEFjdGl2ZVByb29mcyhwcm9vZnMpO1xuICAgICAgXG4gICAgICAvLyBGb3Igbm93LCB1c2UgZW1wdHkgYXJyYXlcbiAgICAgIHNldEFjdGl2ZVByb29mcyhbXSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzZXRFcnJvcignRmFpbGVkIHRvIHJlZnJlc2ggcHJvb2ZzJyk7XG4gICAgICBjb25zb2xlLmVycm9yKCdQcm9vZnMgcmVmcmVzaCBlcnJvcjonLCBlcnIpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBzZXRQcml2YWN5TW9kZSA9IChlbmFibGVkOiBib29sZWFuKSA9PiB7XG4gICAgc2V0UHJpdmFjeU1vZGVTdGF0ZShlbmFibGVkKTtcbiAgICAvLyBJbiByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIG1pZ2h0IGFsc28gdXBkYXRlIHNlcnZlci1zaWRlIHByZWZlcmVuY2VzXG4gIH07XG5cbiAgY29uc3QgZ2VuZXJhdGVQcm9vZiA9IGFzeW5jICh0eXBlOiAndGhyZXNob2xkJyB8ICdzZWxlY3RpdmUnIHwgJ2Z1bGwnLCBvcHRpb25zOiBhbnkpOiBQcm9taXNlPFpLUHJvb2YgfCBudWxsPiA9PiB7XG4gICAgaWYgKCFjb25uZWN0ZWRBZGRyZXNzKSByZXR1cm4gbnVsbDtcbiAgICBcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHRyeSB7XG4gICAgICAvLyBJbiByZWFsIGltcGxlbWVudGF0aW9uOlxuICAgICAgLy8gY29uc3QgcHJvb2YgPSBhd2FpdCBjcmVkaXRJbnRlbGxpZ2VuY2VTZXJ2aWNlLmdlbmVyYXRlWktQcm9vZihjb25uZWN0ZWRBZGRyZXNzLCB0eXBlLCBvcHRpb25zKTtcbiAgICAgIFxuICAgICAgLy8gRm9yIG5vdywgY3JlYXRlIGEgbW9jayBwcm9vZlxuICAgICAgY29uc3QgbW9ja1Byb29mOiBaS1Byb29mID0ge1xuICAgICAgICBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLFxuICAgICAgICB0eXBlLFxuICAgICAgICBzdGF0dXM6ICdyZWFkeScsXG4gICAgICAgIHRocmVzaG9sZDogdHlwZSA9PT0gJ3RocmVzaG9sZCcgPyBvcHRpb25zLnRocmVzaG9sZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgZGltZW5zaW9uczogdHlwZSA9PT0gJ3NlbGVjdGl2ZScgPyBvcHRpb25zLmRpbWVuc2lvbnMgOiB1bmRlZmluZWQsXG4gICAgICAgIHByb29mOiBgemske01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKX0ke0RhdGUubm93KCl9YCxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBleHBpcmVzQXQ6IERhdGUubm93KCkgKyA4NjQwMDAwMCAvLyAyNCBob3Vyc1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgc2V0QWN0aXZlUHJvb2ZzKHByZXYgPT4gW21vY2tQcm9vZiwgLi4ucHJldl0pO1xuICAgICAgcmV0dXJuIG1vY2tQcm9vZjtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gZ2VuZXJhdGUgcHJvb2YnKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Byb29mIGdlbmVyYXRpb24gZXJyb3I6JywgZXJyKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgY2xhaW1BY2hpZXZlbWVudCA9IGFzeW5jIChhY2hpZXZlbWVudElkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICBpZiAoIWNvbm5lY3RlZEFkZHJlc3MpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gSW4gcmVhbCBpbXBsZW1lbnRhdGlvbjpcbiAgICAgIC8vIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCBjcmVkaXRJbnRlbGxpZ2VuY2VTZXJ2aWNlLmNsYWltQWNoaWV2ZW1lbnQoY29ubmVjdGVkQWRkcmVzcywgYWNoaWV2ZW1lbnRJZCk7XG4gICAgICBcbiAgICAgIC8vIEZvciBub3csIGp1c3QgbWFyayBhcyB1bmxvY2tlZFxuICAgICAgc2V0QWNoaWV2ZW1lbnRzKHByZXYgPT4gXG4gICAgICAgIHByZXYubWFwKGFjaGlldmVtZW50ID0+IFxuICAgICAgICAgIGFjaGlldmVtZW50LmlkID09PSBhY2hpZXZlbWVudElkIFxuICAgICAgICAgICAgPyB7IC4uLmFjaGlldmVtZW50LCB1bmxvY2tlZDogdHJ1ZSwgdW5sb2NrZWRBdDogRGF0ZS5ub3coKSB9XG4gICAgICAgICAgICA6IGFjaGlldmVtZW50XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gY2xhaW0gYWNoaWV2ZW1lbnQnKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FjaGlldmVtZW50IGNsYWltIGVycm9yOicsIGVycik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGV4cG9ydERhdGEgPSBhc3luYyAob3B0aW9uczogYW55KTogUHJvbWlzZTxCbG9iIHwgbnVsbD4gPT4ge1xuICAgIGlmICghY29ubmVjdGVkQWRkcmVzcykgcmV0dXJuIG51bGw7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIEluIHJlYWwgaW1wbGVtZW50YXRpb246XG4gICAgICAvLyByZXR1cm4gYXdhaXQgY3JlZGl0SW50ZWxsaWdlbmNlU2VydmljZS5leHBvcnRBbmFseXRpY3MoY29ubmVjdGVkQWRkcmVzcywgb3B0aW9ucyk7XG4gICAgICBcbiAgICAgIC8vIEZvciBub3csIGNyZWF0ZSBhIG1vY2sgZXhwb3J0XG4gICAgICBjb25zdCBleHBvcnREYXRhID0ge1xuICAgICAgICBwcm9maWxlOiBwcml2YWN5TW9kZSA/IG51bGwgOiBwcm9maWxlLFxuICAgICAgICBhbmFseXRpY3M6IHByaXZhY3lNb2RlID8gbnVsbCA6IGFuYWx5dGljcyxcbiAgICAgICAgYWNoaWV2ZW1lbnRzLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgcHJpdmFjeU1vZGVcbiAgICAgIH07XG4gICAgICBcbiAgICAgIHJldHVybiBuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkoZXhwb3J0RGF0YSwgbnVsbCwgMildLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gZXhwb3J0IGRhdGEnKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0RhdGEgZXhwb3J0IGVycm9yOicsIGVycik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdmFsdWU6IENyZWRpdEludGVsbGlnZW5jZUNvbnRleHRUeXBlID0ge1xuICAgIC8vIFN0YXRlXG4gICAgcHJvZmlsZSxcbiAgICBhbmFseXRpY3MsXG4gICAgYWNoaWV2ZW1lbnRzLFxuICAgIGFjdGl2ZVByb29mcyxcbiAgICBsb2FkaW5nLFxuICAgIGVycm9yLFxuICAgIFxuICAgIC8vIFVzZXIgcHJlZmVyZW5jZXNcbiAgICBwcml2YWN5TW9kZSxcbiAgICBjb25uZWN0ZWRBZGRyZXNzLFxuICAgIFxuICAgIC8vIEFjdGlvbnNcbiAgICBjb25uZWN0V2FsbGV0LFxuICAgIGRpc2Nvbm5lY3RXYWxsZXQsXG4gICAgcmVmcmVzaFByb2ZpbGUsXG4gICAgcmVmcmVzaEFuYWx5dGljcyxcbiAgICByZWZyZXNoQWNoaWV2ZW1lbnRzLFxuICAgIHJlZnJlc2hQcm9vZnMsXG4gICAgc2V0UHJpdmFjeU1vZGUsXG4gICAgZ2VuZXJhdGVQcm9vZixcbiAgICBjbGFpbUFjaGlldmVtZW50LFxuICAgIGV4cG9ydERhdGFcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxDcmVkaXRJbnRlbGxpZ2VuY2VDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt2YWx1ZX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9DcmVkaXRJbnRlbGxpZ2VuY2VDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IHVzZUNyZWRpdEludGVsbGlnZW5jZSA9ICgpOiBDcmVkaXRJbnRlbGxpZ2VuY2VDb250ZXh0VHlwZSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KENyZWRpdEludGVsbGlnZW5jZUNvbnRleHQpO1xuICBpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VDcmVkaXRJbnRlbGxpZ2VuY2UgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIENyZWRpdEludGVsbGlnZW5jZVByb3ZpZGVyJyk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDcmVkaXRJbnRlbGxpZ2VuY2VDb250ZXh0OyJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJDcmVkaXRJbnRlbGxpZ2VuY2VDb250ZXh0IiwidW5kZWZpbmVkIiwiQ3JlZGl0SW50ZWxsaWdlbmNlUHJvdmlkZXIiLCJjaGlsZHJlbiIsInByb2ZpbGUiLCJzZXRQcm9maWxlIiwiYW5hbHl0aWNzIiwic2V0QW5hbHl0aWNzIiwiYWNoaWV2ZW1lbnRzIiwic2V0QWNoaWV2ZW1lbnRzIiwiYWN0aXZlUHJvb2ZzIiwic2V0QWN0aXZlUHJvb2ZzIiwibG9hZGluZyIsInNldExvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwicHJpdmFjeU1vZGUiLCJzZXRQcml2YWN5TW9kZVN0YXRlIiwiY29ubmVjdGVkQWRkcmVzcyIsInNldENvbm5lY3RlZEFkZHJlc3MiLCJtb2NrUHJvZmlsZSIsImFkZHJlc3MiLCJsaW5rZWRXYWxsZXRzIiwib3ZlcmFsbFNjb3JlIiwidGllciIsImRpbWVuc2lvbnMiLCJkZWZpUmVsaWFiaWxpdHkiLCJzY29yZSIsImNvbmZpZGVuY2UiLCJ0cmVuZCIsImRhdGFQb2ludHMiLCJsYXN0Q2FsY3VsYXRlZCIsIkRhdGUiLCJub3ciLCJyZWNvbW1lbmRhdGlvbnMiLCJ0cmFkaW5nQ29uc2lzdGVuY3kiLCJzdGFraW5nQ29tbWl0bWVudCIsImdvdmVybmFuY2VQYXJ0aWNpcGF0aW9uIiwibGlxdWlkaXR5UHJvdmlkZXIiLCJzb2NpYWxDcmVkaXQiLCJvdmVyYWxsUmF0aW5nIiwidG90YWxUcmFuc2FjdGlvbnMiLCJzdWNjZXNzUmF0ZSIsImNvbW11bml0eVJhbmsiLCJyZWZlcnJhbHMiLCJ0cnVzdFNjb3JlIiwicDJwTGVuZGluZ0hpc3RvcnkiLCJjb21tdW5pdHlGZWVkYmFjayIsImRpc3B1dGVIaXN0b3J5IiwicHJlZGljdGlvbnMiLCJyaXNrMzBkIiwicmlzazkwZCIsInJpc2sxODBkIiwiaW5zaWdodHMiLCJtYXJrZXRWb2xhdGlsaXR5QWRqdXN0bWVudCIsImxhc3RVcGRhdGVkIiwibW9ja0FuYWx5dGljcyIsInNjb3JlSGlzdG9yeSIsInRpbWVzdGFtcCIsImJlaGF2aW9yVHJlbmRzIiwiY2F0ZWdvcnkiLCJjaGFuZ2UiLCJ0aW1lZnJhbWUiLCJwZWVyQ29tcGFyaXNvbiIsInBlcmNlbnRpbGUiLCJhdmVyYWdlU2NvcmUiLCJ1c2VyU2NvcmUiLCJ0b3RhbFVzZXJzIiwidHJhbnNhY3Rpb25NZXRyaWNzIiwidG90YWxWb2x1bWUiLCJ1bmlxdWVQcm90b2NvbHMiLCJtb2NrQWNoaWV2ZW1lbnRzIiwiaWQiLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJyYXJpdHkiLCJwcm9ncmVzcyIsIm1heFByb2dyZXNzIiwidW5sb2NrZWQiLCJyZXdhcmQiLCJ1bmxvY2tlZEF0IiwibG9hZFByb2ZpbGVEYXRhIiwicHJvZmlsZVJlc3BvbnNlIiwiZmV0Y2giLCJvayIsInByb2ZpbGVEYXRhIiwianNvbiIsImFuYWx5dGljc1Jlc3BvbnNlIiwiYW5hbHl0aWNzRGF0YSIsImNvbnNvbGUiLCJjb25uZWN0V2FsbGV0IiwiZXJyIiwiZGlzY29ubmVjdFdhbGxldCIsInJlZnJlc2hQcm9maWxlIiwicmVmcmVzaEFuYWx5dGljcyIsInJlZnJlc2hBY2hpZXZlbWVudHMiLCJyZWZyZXNoUHJvb2ZzIiwic2V0UHJpdmFjeU1vZGUiLCJlbmFibGVkIiwiZ2VuZXJhdGVQcm9vZiIsInR5cGUiLCJvcHRpb25zIiwibW9ja1Byb29mIiwidG9TdHJpbmciLCJzdGF0dXMiLCJ0aHJlc2hvbGQiLCJwcm9vZiIsIk1hdGgiLCJyYW5kb20iLCJzdWJzdHJpbmciLCJleHBpcmVzQXQiLCJwcmV2IiwiY2xhaW1BY2hpZXZlbWVudCIsImFjaGlldmVtZW50SWQiLCJtYXAiLCJhY2hpZXZlbWVudCIsImV4cG9ydERhdGEiLCJ0b0lTT1N0cmluZyIsIkJsb2IiLCJKU09OIiwic3RyaW5naWZ5IiwidmFsdWUiLCJQcm92aWRlciIsInVzZUNyZWRpdEludGVsbGlnZW5jZSIsImNvbnRleHQiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./contexts/CreditIntelligenceContext.tsx\n"));

/***/ })

});