"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./contexts/CreditIntelligenceContext.tsx":
/*!************************************************!*\
  !*** ./contexts/CreditIntelligenceContext.tsx ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CreditIntelligenceProvider: function() { return /* binding */ CreditIntelligenceProvider; },\n/* harmony export */   useCreditIntelligence: function() { return /* binding */ useCreditIntelligence; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\nconst CreditIntelligenceContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst CreditIntelligenceProvider = (param)=>{\n    let { children } = param;\n    _s();\n    const [profile, setProfile] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [analytics, setAnalytics] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [achievements, setAchievements] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [activeProofs, setActiveProofs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [privacyMode, setPrivacyModeState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [connectedAddress, setConnectedAddress] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    // Mock data for demonstration - in real implementation, this would come from the service\n    // Load data from API when address is connected\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (connectedAddress) {\n            loadProfileData(connectedAddress);\n        } else {\n            setProfile(null);\n            setAnalytics(null);\n            setAchievements([]);\n            setActiveProofs([]);\n        }\n    }, [\n        connectedAddress\n    ]);\n    const loadProfileData = async (address)=>{\n        setLoading(true);\n        try {\n            // Load profile from API\n            const profileResponse = await fetch(\"http://localhost:3001/api/credit-profile/\".concat(address));\n            if (profileResponse.ok) {\n                const profileData = await profileResponse.json();\n                setProfile(profileData);\n                setAchievements(profileData.achievements || []);\n            }\n            // Load analytics from API\n            const analyticsResponse = await fetch(\"http://localhost:3001/api/analytics/\".concat(address, \"?timeframe=30d\"));\n            if (analyticsResponse.ok) {\n                const analyticsData = await analyticsResponse.json();\n                setAnalytics(analyticsData);\n            }\n        } catch (error) {\n            console.error(\"Error loading profile data:\", error);\n            setError(\"Failed to load profile data\");\n        } finally{\n            setLoading(false);\n        }\n    };\n    const connectWallet = async (address)=>{\n        setLoading(true);\n        setError(null);\n        try {\n            setConnectedAddress(address);\n        // In real implementation, fetch actual data from the service\n        // const profile = await creditIntelligenceService.getCreditProfile(address);\n        // setProfile(profile);\n        } catch (err) {\n            setError(\"Failed to connect wallet and load profile\");\n            console.error(\"Wallet connection error:\", err);\n        } finally{\n            setLoading(false);\n        }\n    };\n    const disconnectWallet = ()=>{\n        setConnectedAddress(null);\n        setProfile(null);\n        setAnalytics(null);\n        setAchievements([]);\n        setActiveProofs([]);\n        setError(null);\n    };\n    const refreshProfile = async ()=>{\n        if (!connectedAddress) return;\n        setLoading(true);\n        try {\n            const response = await fetch(\"http://localhost:3001/api/credit-profile/\".concat(connectedAddress));\n            if (response.ok) {\n                const profileData = await response.json();\n                setProfile(profileData);\n                setAchievements(profileData.achievements || []);\n            } else {\n                setError(\"Failed to refresh profile\");\n            }\n        } catch (err) {\n            setError(\"Failed to refresh profile\");\n            console.error(\"Profile refresh error:\", err);\n        } finally{\n            setLoading(false);\n        }\n    };\n    const refreshAnalytics = async function() {\n        let timeframe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"30d\";\n        if (!connectedAddress) return;\n        setLoading(true);\n        try {\n            const response = await fetch(\"http://localhost:3001/api/analytics/\".concat(connectedAddress, \"?timeframe=\").concat(timeframe));\n            if (response.ok) {\n                const analyticsData = await response.json();\n                setAnalytics(analyticsData);\n            } else {\n                setError(\"Failed to refresh analytics\");\n            }\n        } catch (err) {\n            setError(\"Failed to refresh analytics\");\n            console.error(\"Analytics refresh error:\", err);\n        } finally{\n            setLoading(false);\n        }\n    };\n    const refreshAchievements = async ()=>{\n        if (!connectedAddress) return;\n        try {\n            // In real implementation:\n            // const achievements = await creditIntelligenceService.getAchievements(connectedAddress);\n            // setAchievements(achievements);\n            // For now, just refresh the mock data\n            setAchievements(mockAchievements);\n        } catch (err) {\n            setError(\"Failed to refresh achievements\");\n            console.error(\"Achievements refresh error:\", err);\n        }\n    };\n    const refreshProofs = async ()=>{\n        if (!connectedAddress) return;\n        try {\n            // In real implementation:\n            // const proofs = await creditIntelligenceService.getActiveProofs(connectedAddress);\n            // setActiveProofs(proofs);\n            // For now, use empty array\n            setActiveProofs([]);\n        } catch (err) {\n            setError(\"Failed to refresh proofs\");\n            console.error(\"Proofs refresh error:\", err);\n        }\n    };\n    const setPrivacyMode = (enabled)=>{\n        setPrivacyModeState(enabled);\n    // In real implementation, this might also update server-side preferences\n    };\n    const generateProof = async (type, options)=>{\n        if (!connectedAddress) return null;\n        setLoading(true);\n        try {\n            // In real implementation:\n            // const proof = await creditIntelligenceService.generateZKProof(connectedAddress, type, options);\n            // For now, create a mock proof\n            const mockProof = {\n                id: Date.now().toString(),\n                type,\n                status: \"ready\",\n                threshold: type === \"threshold\" ? options.threshold : undefined,\n                dimensions: type === \"selective\" ? options.dimensions : undefined,\n                proof: \"zk\".concat(Math.random().toString(36).substring(2)).concat(Date.now()),\n                timestamp: Date.now(),\n                expiresAt: Date.now() + 86400000 // 24 hours\n            };\n            setActiveProofs((prev)=>[\n                    mockProof,\n                    ...prev\n                ]);\n            return mockProof;\n        } catch (err) {\n            setError(\"Failed to generate proof\");\n            console.error(\"Proof generation error:\", err);\n            return null;\n        } finally{\n            setLoading(false);\n        }\n    };\n    const claimAchievement = async (achievementId)=>{\n        if (!connectedAddress) return false;\n        try {\n            // In real implementation:\n            // const success = await creditIntelligenceService.claimAchievement(connectedAddress, achievementId);\n            // For now, just mark as unlocked\n            setAchievements((prev)=>prev.map((achievement)=>achievement.id === achievementId ? {\n                        ...achievement,\n                        unlocked: true,\n                        unlockedAt: Date.now()\n                    } : achievement));\n            return true;\n        } catch (err) {\n            setError(\"Failed to claim achievement\");\n            console.error(\"Achievement claim error:\", err);\n            return false;\n        }\n    };\n    const exportData = async (options)=>{\n        if (!connectedAddress) return null;\n        try {\n            // In real implementation:\n            // return await creditIntelligenceService.exportAnalytics(connectedAddress, options);\n            // For now, create a mock export\n            const exportData = {\n                profile: privacyMode ? null : profile,\n                analytics: privacyMode ? null : analytics,\n                achievements,\n                timestamp: new Date().toISOString(),\n                privacyMode\n            };\n            return new Blob([\n                JSON.stringify(exportData, null, 2)\n            ], {\n                type: \"application/json\"\n            });\n        } catch (err) {\n            setError(\"Failed to export data\");\n            console.error(\"Data export error:\", err);\n            return null;\n        }\n    };\n    const value = {\n        // State\n        profile,\n        analytics,\n        achievements,\n        activeProofs,\n        loading,\n        error,\n        // User preferences\n        privacyMode,\n        connectedAddress,\n        // Actions\n        connectWallet,\n        disconnectWallet,\n        refreshProfile,\n        refreshAnalytics,\n        refreshAchievements,\n        refreshProofs,\n        setPrivacyMode,\n        generateProof,\n        claimAchievement,\n        exportData\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(CreditIntelligenceContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"E:\\\\BlockCreditScore\\\\frontend\\\\contexts\\\\CreditIntelligenceContext.tsx\",\n        lineNumber: 372,\n        columnNumber: 5\n    }, undefined);\n};\n_s(CreditIntelligenceProvider, \"hJO1dXMM86F7xpGg6F2fu6JUh/8=\");\n_c = CreditIntelligenceProvider;\nconst useCreditIntelligence = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(CreditIntelligenceContext);\n    if (context === undefined) {\n        throw new Error(\"useCreditIntelligence must be used within a CreditIntelligenceProvider\");\n    }\n    return context;\n};\n_s1(useCreditIntelligence, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n/* harmony default export */ __webpack_exports__[\"default\"] = (CreditIntelligenceContext);\nvar _c;\n$RefreshReg$(_c, \"CreditIntelligenceProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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L0NyZWRpdEludGVsbGlnZW5jZUNvbnRleHQudHN4PzQ3NmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcblxuaW50ZXJmYWNlIFNjb3JlRGltZW5zaW9uIHtcbiAgc2NvcmU6IG51bWJlcjtcbiAgY29uZmlkZW5jZTogbnVtYmVyO1xuICB0cmVuZDogJ2ltcHJvdmluZycgfCAnc3RhYmxlJyB8ICdkZWNsaW5pbmcnO1xuICBkYXRhUG9pbnRzOiBudW1iZXI7XG4gIGxhc3RDYWxjdWxhdGVkOiBudW1iZXI7XG4gIHJlY29tbWVuZGF0aW9uczogc3RyaW5nW107XG59XG5cbmludGVyZmFjZSBTb2NpYWxDcmVkaXREYXRhIHtcbiAgb3ZlcmFsbFJhdGluZzogbnVtYmVyO1xuICB0b3RhbFRyYW5zYWN0aW9uczogbnVtYmVyO1xuICBzdWNjZXNzUmF0ZTogbnVtYmVyO1xuICBjb21tdW5pdHlSYW5rOiBudW1iZXI7XG4gIHJlZmVycmFsczogbnVtYmVyO1xuICB0cnVzdFNjb3JlOiBudW1iZXI7XG4gIHAycExlbmRpbmdIaXN0b3J5OiBhbnlbXTtcbiAgY29tbXVuaXR5RmVlZGJhY2s6IGFueVtdO1xuICBkaXNwdXRlSGlzdG9yeTogYW55W107XG59XG5cbmludGVyZmFjZSBSaXNrUHJlZGljdGlvbiB7XG4gIHJpc2szMGQ6IG51bWJlcjtcbiAgcmlzazkwZDogbnVtYmVyO1xuICByaXNrMTgwZDogbnVtYmVyO1xuICBjb25maWRlbmNlOiBudW1iZXI7XG4gIGluc2lnaHRzOiBzdHJpbmdbXTtcbiAgbWFya2V0Vm9sYXRpbGl0eUFkanVzdG1lbnQ6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIEFjaGlldmVtZW50IHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICByYXJpdHk6ICdjb21tb24nIHwgJ3JhcmUnIHwgJ2VwaWMnIHwgJ2xlZ2VuZGFyeSc7XG4gIHByb2dyZXNzOiBudW1iZXI7XG4gIG1heFByb2dyZXNzOiBudW1iZXI7XG4gIHVubG9ja2VkOiBib29sZWFuO1xuICByZXdhcmQ6IHN0cmluZztcbiAgdW5sb2NrZWRBdD86IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIENyZWRpdFByb2ZpbGUge1xuICBhZGRyZXNzOiBzdHJpbmc7XG4gIGxpbmtlZFdhbGxldHM6IHN0cmluZ1tdO1xuICBvdmVyYWxsU2NvcmU6IG51bWJlcjtcbiAgdGllcjogc3RyaW5nO1xuICBkaW1lbnNpb25zOiB7XG4gICAgZGVmaVJlbGlhYmlsaXR5OiBTY29yZURpbWVuc2lvbjtcbiAgICB0cmFkaW5nQ29uc2lzdGVuY3k6IFNjb3JlRGltZW5zaW9uO1xuICAgIHN0YWtpbmdDb21taXRtZW50OiBTY29yZURpbWVuc2lvbjtcbiAgICBnb3Zlcm5hbmNlUGFydGljaXBhdGlvbjogU2NvcmVEaW1lbnNpb247XG4gICAgbGlxdWlkaXR5UHJvdmlkZXI6IFNjb3JlRGltZW5zaW9uO1xuICB9O1xuICBzb2NpYWxDcmVkaXQ6IFNvY2lhbENyZWRpdERhdGE7XG4gIHByZWRpY3Rpb25zOiBSaXNrUHJlZGljdGlvbjtcbiAgYWNoaWV2ZW1lbnRzOiBBY2hpZXZlbWVudFtdO1xuICBsYXN0VXBkYXRlZDogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgQW5hbHl0aWNzRGF0YSB7XG4gIHNjb3JlSGlzdG9yeTogYW55W107XG4gIGJlaGF2aW9yVHJlbmRzOiBhbnlbXTtcbiAgcGVlckNvbXBhcmlzb246IGFueTtcbiAgdHJhbnNhY3Rpb25NZXRyaWNzOiBhbnk7XG59XG5cbmludGVyZmFjZSBaS1Byb29mIHtcbiAgaWQ6IHN0cmluZztcbiAgdHlwZTogJ3RocmVzaG9sZCcgfCAnc2VsZWN0aXZlJyB8ICdmdWxsJztcbiAgc3RhdHVzOiAnZ2VuZXJhdGluZycgfCAncmVhZHknIHwgJ3ZlcmlmaWVkJyB8ICdleHBpcmVkJztcbiAgdGhyZXNob2xkPzogbnVtYmVyO1xuICBkaW1lbnNpb25zPzogc3RyaW5nW107XG4gIHByb29mOiBzdHJpbmc7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xuICBleHBpcmVzQXQ6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIENyZWRpdEludGVsbGlnZW5jZUNvbnRleHRUeXBlIHtcbiAgLy8gU3RhdGVcbiAgcHJvZmlsZTogQ3JlZGl0UHJvZmlsZSB8IG51bGw7XG4gIGFuYWx5dGljczogQW5hbHl0aWNzRGF0YSB8IG51bGw7XG4gIGFjaGlldmVtZW50czogQWNoaWV2ZW1lbnRbXTtcbiAgYWN0aXZlUHJvb2ZzOiBaS1Byb29mW107XG4gIGxvYWRpbmc6IGJvb2xlYW47XG4gIGVycm9yOiBzdHJpbmcgfCBudWxsO1xuICBcbiAgLy8gVXNlciBwcmVmZXJlbmNlc1xuICBwcml2YWN5TW9kZTogYm9vbGVhbjtcbiAgY29ubmVjdGVkQWRkcmVzczogc3RyaW5nIHwgbnVsbDtcbiAgXG4gIC8vIEFjdGlvbnNcbiAgY29ubmVjdFdhbGxldDogKGFkZHJlc3M6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgZGlzY29ubmVjdFdhbGxldDogKCkgPT4gdm9pZDtcbiAgcmVmcmVzaFByb2ZpbGU6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIHJlZnJlc2hBbmFseXRpY3M6ICh0aW1lZnJhbWU/OiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gIHJlZnJlc2hBY2hpZXZlbWVudHM6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIHJlZnJlc2hQcm9vZnM6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIHNldFByaXZhY3lNb2RlOiAoZW5hYmxlZDogYm9vbGVhbikgPT4gdm9pZDtcbiAgZ2VuZXJhdGVQcm9vZjogKHR5cGU6ICd0aHJlc2hvbGQnIHwgJ3NlbGVjdGl2ZScgfCAnZnVsbCcsIG9wdGlvbnM6IGFueSkgPT4gUHJvbWlzZTxaS1Byb29mIHwgbnVsbD47XG4gIGNsYWltQWNoaWV2ZW1lbnQ6IChhY2hpZXZlbWVudElkOiBzdHJpbmcpID0+IFByb21pc2U8Ym9vbGVhbj47XG4gIGV4cG9ydERhdGE6IChvcHRpb25zOiBhbnkpID0+IFByb21pc2U8QmxvYiB8IG51bGw+O1xufVxuXG5jb25zdCBDcmVkaXRJbnRlbGxpZ2VuY2VDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxDcmVkaXRJbnRlbGxpZ2VuY2VDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuaW50ZXJmYWNlIENyZWRpdEludGVsbGlnZW5jZVByb3ZpZGVyUHJvcHMge1xuICBjaGlsZHJlbjogUmVhY3ROb2RlO1xufVxuXG5leHBvcnQgY29uc3QgQ3JlZGl0SW50ZWxsaWdlbmNlUHJvdmlkZXI6IFJlYWN0LkZDPENyZWRpdEludGVsbGlnZW5jZVByb3ZpZGVyUHJvcHM+ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBbcHJvZmlsZSwgc2V0UHJvZmlsZV0gPSB1c2VTdGF0ZTxDcmVkaXRQcm9maWxlIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFthbmFseXRpY3MsIHNldEFuYWx5dGljc10gPSB1c2VTdGF0ZTxBbmFseXRpY3NEYXRhIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFthY2hpZXZlbWVudHMsIHNldEFjaGlldmVtZW50c10gPSB1c2VTdGF0ZTxBY2hpZXZlbWVudFtdPihbXSk7XG4gIGNvbnN0IFthY3RpdmVQcm9vZnMsIHNldEFjdGl2ZVByb29mc10gPSB1c2VTdGF0ZTxaS1Byb29mW10+KFtdKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbcHJpdmFjeU1vZGUsIHNldFByaXZhY3lNb2RlU3RhdGVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbY29ubmVjdGVkQWRkcmVzcywgc2V0Q29ubmVjdGVkQWRkcmVzc10gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICAvLyBNb2NrIGRhdGEgZm9yIGRlbW9uc3RyYXRpb24gLSBpbiByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIGNvbWUgZnJvbSB0aGUgc2VydmljZVxuXG5cbiAgLy8gTG9hZCBkYXRhIGZyb20gQVBJIHdoZW4gYWRkcmVzcyBpcyBjb25uZWN0ZWRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY29ubmVjdGVkQWRkcmVzcykge1xuICAgICAgbG9hZFByb2ZpbGVEYXRhKGNvbm5lY3RlZEFkZHJlc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRQcm9maWxlKG51bGwpO1xuICAgICAgc2V0QW5hbHl0aWNzKG51bGwpO1xuICAgICAgc2V0QWNoaWV2ZW1lbnRzKFtdKTtcbiAgICAgIHNldEFjdGl2ZVByb29mcyhbXSk7XG4gICAgfVxuICB9LCBbY29ubmVjdGVkQWRkcmVzc10pO1xuXG4gIGNvbnN0IGxvYWRQcm9maWxlRGF0YSA9IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHRyeSB7XG4gICAgICAvLyBMb2FkIHByb2ZpbGUgZnJvbSBBUElcbiAgICAgIGNvbnN0IHByb2ZpbGVSZXNwb25zZSA9IGF3YWl0IGZldGNoKGBodHRwOi8vbG9jYWxob3N0OjMwMDEvYXBpL2NyZWRpdC1wcm9maWxlLyR7YWRkcmVzc31gKTtcbiAgICAgIGlmIChwcm9maWxlUmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgcHJvZmlsZURhdGEgPSBhd2FpdCBwcm9maWxlUmVzcG9uc2UuanNvbigpO1xuICAgICAgICBzZXRQcm9maWxlKHByb2ZpbGVEYXRhKTtcbiAgICAgICAgc2V0QWNoaWV2ZW1lbnRzKHByb2ZpbGVEYXRhLmFjaGlldmVtZW50cyB8fCBbXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIExvYWQgYW5hbHl0aWNzIGZyb20gQVBJXG4gICAgICBjb25zdCBhbmFseXRpY3NSZXNwb25zZSA9IGF3YWl0IGZldGNoKGBodHRwOi8vbG9jYWxob3N0OjMwMDEvYXBpL2FuYWx5dGljcy8ke2FkZHJlc3N9P3RpbWVmcmFtZT0zMGRgKTtcbiAgICAgIGlmIChhbmFseXRpY3NSZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBhbmFseXRpY3NEYXRhID0gYXdhaXQgYW5hbHl0aWNzUmVzcG9uc2UuanNvbigpO1xuICAgICAgICBzZXRBbmFseXRpY3MoYW5hbHl0aWNzRGF0YSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgcHJvZmlsZSBkYXRhOicsIGVycm9yKTtcbiAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gbG9hZCBwcm9maWxlIGRhdGEnKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGNvbm5lY3RXYWxsZXQgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKSA9PiB7XG4gICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgc2V0Q29ubmVjdGVkQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgIC8vIEluIHJlYWwgaW1wbGVtZW50YXRpb24sIGZldGNoIGFjdHVhbCBkYXRhIGZyb20gdGhlIHNlcnZpY2VcbiAgICAgIC8vIGNvbnN0IHByb2ZpbGUgPSBhd2FpdCBjcmVkaXRJbnRlbGxpZ2VuY2VTZXJ2aWNlLmdldENyZWRpdFByb2ZpbGUoYWRkcmVzcyk7XG4gICAgICAvLyBzZXRQcm9maWxlKHByb2ZpbGUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byBjb25uZWN0IHdhbGxldCBhbmQgbG9hZCBwcm9maWxlJyk7XG4gICAgICBjb25zb2xlLmVycm9yKCdXYWxsZXQgY29ubmVjdGlvbiBlcnJvcjonLCBlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZGlzY29ubmVjdFdhbGxldCA9ICgpID0+IHtcbiAgICBzZXRDb25uZWN0ZWRBZGRyZXNzKG51bGwpO1xuICAgIHNldFByb2ZpbGUobnVsbCk7XG4gICAgc2V0QW5hbHl0aWNzKG51bGwpO1xuICAgIHNldEFjaGlldmVtZW50cyhbXSk7XG4gICAgc2V0QWN0aXZlUHJvb2ZzKFtdKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgfTtcblxuICBjb25zdCByZWZyZXNoUHJvZmlsZSA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWNvbm5lY3RlZEFkZHJlc3MpIHJldHVybjtcbiAgICBcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGBodHRwOi8vbG9jYWxob3N0OjMwMDEvYXBpL2NyZWRpdC1wcm9maWxlLyR7Y29ubmVjdGVkQWRkcmVzc31gKTtcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBwcm9maWxlRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgc2V0UHJvZmlsZShwcm9maWxlRGF0YSk7XG4gICAgICAgIHNldEFjaGlldmVtZW50cyhwcm9maWxlRGF0YS5hY2hpZXZlbWVudHMgfHwgW10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byByZWZyZXNoIHByb2ZpbGUnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gcmVmcmVzaCBwcm9maWxlJyk7XG4gICAgICBjb25zb2xlLmVycm9yKCdQcm9maWxlIHJlZnJlc2ggZXJyb3I6JywgZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJlZnJlc2hBbmFseXRpY3MgPSBhc3luYyAodGltZWZyYW1lOiBzdHJpbmcgPSAnMzBkJykgPT4ge1xuICAgIGlmICghY29ubmVjdGVkQWRkcmVzcykgcmV0dXJuO1xuICAgIFxuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYGh0dHA6Ly9sb2NhbGhvc3Q6MzAwMS9hcGkvYW5hbHl0aWNzLyR7Y29ubmVjdGVkQWRkcmVzc30/dGltZWZyYW1lPSR7dGltZWZyYW1lfWApO1xuICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGFuYWx5dGljc0RhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHNldEFuYWx5dGljcyhhbmFseXRpY3NEYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gcmVmcmVzaCBhbmFseXRpY3MnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gcmVmcmVzaCBhbmFseXRpY3MnKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FuYWx5dGljcyByZWZyZXNoIGVycm9yOicsIGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCByZWZyZXNoQWNoaWV2ZW1lbnRzID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghY29ubmVjdGVkQWRkcmVzcykgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBJbiByZWFsIGltcGxlbWVudGF0aW9uOlxuICAgICAgLy8gY29uc3QgYWNoaWV2ZW1lbnRzID0gYXdhaXQgY3JlZGl0SW50ZWxsaWdlbmNlU2VydmljZS5nZXRBY2hpZXZlbWVudHMoY29ubmVjdGVkQWRkcmVzcyk7XG4gICAgICAvLyBzZXRBY2hpZXZlbWVudHMoYWNoaWV2ZW1lbnRzKTtcbiAgICAgIFxuICAgICAgLy8gRm9yIG5vdywganVzdCByZWZyZXNoIHRoZSBtb2NrIGRhdGFcbiAgICAgIHNldEFjaGlldmVtZW50cyhtb2NrQWNoaWV2ZW1lbnRzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gcmVmcmVzaCBhY2hpZXZlbWVudHMnKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FjaGlldmVtZW50cyByZWZyZXNoIGVycm9yOicsIGVycik7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJlZnJlc2hQcm9vZnMgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFjb25uZWN0ZWRBZGRyZXNzKSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIEluIHJlYWwgaW1wbGVtZW50YXRpb246XG4gICAgICAvLyBjb25zdCBwcm9vZnMgPSBhd2FpdCBjcmVkaXRJbnRlbGxpZ2VuY2VTZXJ2aWNlLmdldEFjdGl2ZVByb29mcyhjb25uZWN0ZWRBZGRyZXNzKTtcbiAgICAgIC8vIHNldEFjdGl2ZVByb29mcyhwcm9vZnMpO1xuICAgICAgXG4gICAgICAvLyBGb3Igbm93LCB1c2UgZW1wdHkgYXJyYXlcbiAgICAgIHNldEFjdGl2ZVByb29mcyhbXSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzZXRFcnJvcignRmFpbGVkIHRvIHJlZnJlc2ggcHJvb2ZzJyk7XG4gICAgICBjb25zb2xlLmVycm9yKCdQcm9vZnMgcmVmcmVzaCBlcnJvcjonLCBlcnIpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBzZXRQcml2YWN5TW9kZSA9IChlbmFibGVkOiBib29sZWFuKSA9PiB7XG4gICAgc2V0UHJpdmFjeU1vZGVTdGF0ZShlbmFibGVkKTtcbiAgICAvLyBJbiByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIG1pZ2h0IGFsc28gdXBkYXRlIHNlcnZlci1zaWRlIHByZWZlcmVuY2VzXG4gIH07XG5cbiAgY29uc3QgZ2VuZXJhdGVQcm9vZiA9IGFzeW5jICh0eXBlOiAndGhyZXNob2xkJyB8ICdzZWxlY3RpdmUnIHwgJ2Z1bGwnLCBvcHRpb25zOiBhbnkpOiBQcm9taXNlPFpLUHJvb2YgfCBudWxsPiA9PiB7XG4gICAgaWYgKCFjb25uZWN0ZWRBZGRyZXNzKSByZXR1cm4gbnVsbDtcbiAgICBcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHRyeSB7XG4gICAgICAvLyBJbiByZWFsIGltcGxlbWVudGF0aW9uOlxuICAgICAgLy8gY29uc3QgcHJvb2YgPSBhd2FpdCBjcmVkaXRJbnRlbGxpZ2VuY2VTZXJ2aWNlLmdlbmVyYXRlWktQcm9vZihjb25uZWN0ZWRBZGRyZXNzLCB0eXBlLCBvcHRpb25zKTtcbiAgICAgIFxuICAgICAgLy8gRm9yIG5vdywgY3JlYXRlIGEgbW9jayBwcm9vZlxuICAgICAgY29uc3QgbW9ja1Byb29mOiBaS1Byb29mID0ge1xuICAgICAgICBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLFxuICAgICAgICB0eXBlLFxuICAgICAgICBzdGF0dXM6ICdyZWFkeScsXG4gICAgICAgIHRocmVzaG9sZDogdHlwZSA9PT0gJ3RocmVzaG9sZCcgPyBvcHRpb25zLnRocmVzaG9sZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgZGltZW5zaW9uczogdHlwZSA9PT0gJ3NlbGVjdGl2ZScgPyBvcHRpb25zLmRpbWVuc2lvbnMgOiB1bmRlZmluZWQsXG4gICAgICAgIHByb29mOiBgemske01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyKX0ke0RhdGUubm93KCl9YCxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBleHBpcmVzQXQ6IERhdGUubm93KCkgKyA4NjQwMDAwMCAvLyAyNCBob3Vyc1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgc2V0QWN0aXZlUHJvb2ZzKHByZXYgPT4gW21vY2tQcm9vZiwgLi4ucHJldl0pO1xuICAgICAgcmV0dXJuIG1vY2tQcm9vZjtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gZ2VuZXJhdGUgcHJvb2YnKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Byb29mIGdlbmVyYXRpb24gZXJyb3I6JywgZXJyKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgY2xhaW1BY2hpZXZlbWVudCA9IGFzeW5jIChhY2hpZXZlbWVudElkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICBpZiAoIWNvbm5lY3RlZEFkZHJlc3MpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gSW4gcmVhbCBpbXBsZW1lbnRhdGlvbjpcbiAgICAgIC8vIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCBjcmVkaXRJbnRlbGxpZ2VuY2VTZXJ2aWNlLmNsYWltQWNoaWV2ZW1lbnQoY29ubmVjdGVkQWRkcmVzcywgYWNoaWV2ZW1lbnRJZCk7XG4gICAgICBcbiAgICAgIC8vIEZvciBub3csIGp1c3QgbWFyayBhcyB1bmxvY2tlZFxuICAgICAgc2V0QWNoaWV2ZW1lbnRzKHByZXYgPT4gXG4gICAgICAgIHByZXYubWFwKGFjaGlldmVtZW50ID0+IFxuICAgICAgICAgIGFjaGlldmVtZW50LmlkID09PSBhY2hpZXZlbWVudElkIFxuICAgICAgICAgICAgPyB7IC4uLmFjaGlldmVtZW50LCB1bmxvY2tlZDogdHJ1ZSwgdW5sb2NrZWRBdDogRGF0ZS5ub3coKSB9XG4gICAgICAgICAgICA6IGFjaGlldmVtZW50XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gY2xhaW0gYWNoaWV2ZW1lbnQnKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FjaGlldmVtZW50IGNsYWltIGVycm9yOicsIGVycik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGV4cG9ydERhdGEgPSBhc3luYyAob3B0aW9uczogYW55KTogUHJvbWlzZTxCbG9iIHwgbnVsbD4gPT4ge1xuICAgIGlmICghY29ubmVjdGVkQWRkcmVzcykgcmV0dXJuIG51bGw7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIEluIHJlYWwgaW1wbGVtZW50YXRpb246XG4gICAgICAvLyByZXR1cm4gYXdhaXQgY3JlZGl0SW50ZWxsaWdlbmNlU2VydmljZS5leHBvcnRBbmFseXRpY3MoY29ubmVjdGVkQWRkcmVzcywgb3B0aW9ucyk7XG4gICAgICBcbiAgICAgIC8vIEZvciBub3csIGNyZWF0ZSBhIG1vY2sgZXhwb3J0XG4gICAgICBjb25zdCBleHBvcnREYXRhID0ge1xuICAgICAgICBwcm9maWxlOiBwcml2YWN5TW9kZSA/IG51bGwgOiBwcm9maWxlLFxuICAgICAgICBhbmFseXRpY3M6IHByaXZhY3lNb2RlID8gbnVsbCA6IGFuYWx5dGljcyxcbiAgICAgICAgYWNoaWV2ZW1lbnRzLFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgcHJpdmFjeU1vZGVcbiAgICAgIH07XG4gICAgICBcbiAgICAgIHJldHVybiBuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkoZXhwb3J0RGF0YSwgbnVsbCwgMildLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gZXhwb3J0IGRhdGEnKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0RhdGEgZXhwb3J0IGVycm9yOicsIGVycik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdmFsdWU6IENyZWRpdEludGVsbGlnZW5jZUNvbnRleHRUeXBlID0ge1xuICAgIC8vIFN0YXRlXG4gICAgcHJvZmlsZSxcbiAgICBhbmFseXRpY3MsXG4gICAgYWNoaWV2ZW1lbnRzLFxuICAgIGFjdGl2ZVByb29mcyxcbiAgICBsb2FkaW5nLFxuICAgIGVycm9yLFxuICAgIFxuICAgIC8vIFVzZXIgcHJlZmVyZW5jZXNcbiAgICBwcml2YWN5TW9kZSxcbiAgICBjb25uZWN0ZWRBZGRyZXNzLFxuICAgIFxuICAgIC8vIEFjdGlvbnNcbiAgICBjb25uZWN0V2FsbGV0LFxuICAgIGRpc2Nvbm5lY3RXYWxsZXQsXG4gICAgcmVmcmVzaFByb2ZpbGUsXG4gICAgcmVmcmVzaEFuYWx5dGljcyxcbiAgICByZWZyZXNoQWNoaWV2ZW1lbnRzLFxuICAgIHJlZnJlc2hQcm9vZnMsXG4gICAgc2V0UHJpdmFjeU1vZGUsXG4gICAgZ2VuZXJhdGVQcm9vZixcbiAgICBjbGFpbUFjaGlldmVtZW50LFxuICAgIGV4cG9ydERhdGFcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxDcmVkaXRJbnRlbGxpZ2VuY2VDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt2YWx1ZX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9DcmVkaXRJbnRlbGxpZ2VuY2VDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IHVzZUNyZWRpdEludGVsbGlnZW5jZSA9ICgpOiBDcmVkaXRJbnRlbGxpZ2VuY2VDb250ZXh0VHlwZSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KENyZWRpdEludGVsbGlnZW5jZUNvbnRleHQpO1xuICBpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VDcmVkaXRJbnRlbGxpZ2VuY2UgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIENyZWRpdEludGVsbGlnZW5jZVByb3ZpZGVyJyk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDcmVkaXRJbnRlbGxpZ2VuY2VDb250ZXh0OyJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJDcmVkaXRJbnRlbGxpZ2VuY2VDb250ZXh0IiwidW5kZWZpbmVkIiwiQ3JlZGl0SW50ZWxsaWdlbmNlUHJvdmlkZXIiLCJjaGlsZHJlbiIsInByb2ZpbGUiLCJzZXRQcm9maWxlIiwiYW5hbHl0aWNzIiwic2V0QW5hbHl0aWNzIiwiYWNoaWV2ZW1lbnRzIiwic2V0QWNoaWV2ZW1lbnRzIiwiYWN0aXZlUHJvb2ZzIiwic2V0QWN0aXZlUHJvb2ZzIiwibG9hZGluZyIsInNldExvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwicHJpdmFjeU1vZGUiLCJzZXRQcml2YWN5TW9kZVN0YXRlIiwiY29ubmVjdGVkQWRkcmVzcyIsInNldENvbm5lY3RlZEFkZHJlc3MiLCJsb2FkUHJvZmlsZURhdGEiLCJhZGRyZXNzIiwicHJvZmlsZVJlc3BvbnNlIiwiZmV0Y2giLCJvayIsInByb2ZpbGVEYXRhIiwianNvbiIsImFuYWx5dGljc1Jlc3BvbnNlIiwiYW5hbHl0aWNzRGF0YSIsImNvbnNvbGUiLCJjb25uZWN0V2FsbGV0IiwiZXJyIiwiZGlzY29ubmVjdFdhbGxldCIsInJlZnJlc2hQcm9maWxlIiwicmVzcG9uc2UiLCJyZWZyZXNoQW5hbHl0aWNzIiwidGltZWZyYW1lIiwicmVmcmVzaEFjaGlldmVtZW50cyIsIm1vY2tBY2hpZXZlbWVudHMiLCJyZWZyZXNoUHJvb2ZzIiwic2V0UHJpdmFjeU1vZGUiLCJlbmFibGVkIiwiZ2VuZXJhdGVQcm9vZiIsInR5cGUiLCJvcHRpb25zIiwibW9ja1Byb29mIiwiaWQiLCJEYXRlIiwibm93IiwidG9TdHJpbmciLCJzdGF0dXMiLCJ0aHJlc2hvbGQiLCJkaW1lbnNpb25zIiwicHJvb2YiLCJNYXRoIiwicmFuZG9tIiwic3Vic3RyaW5nIiwidGltZXN0YW1wIiwiZXhwaXJlc0F0IiwicHJldiIsImNsYWltQWNoaWV2ZW1lbnQiLCJhY2hpZXZlbWVudElkIiwibWFwIiwiYWNoaWV2ZW1lbnQiLCJ1bmxvY2tlZCIsInVubG9ja2VkQXQiLCJleHBvcnREYXRhIiwidG9JU09TdHJpbmciLCJCbG9iIiwiSlNPTiIsInN0cmluZ2lmeSIsInZhbHVlIiwiUHJvdmlkZXIiLCJ1c2VDcmVkaXRJbnRlbGxpZ2VuY2UiLCJjb250ZXh0IiwiRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./contexts/CreditIntelligenceContext.tsx\n"));

/***/ })

});